import pandas
import numpy 
import os 
import difflib
from sklearn.model_selection import train_test_split
from sklearn.svm import SVC  
from sklearn.metrics import classification_report, confusion_matrix 
import matplotlib.pyplot as plt 
import seaborn as sns

NUM_ITERATIONS = 10000
MAX_NUM_VALUES = 10
SEQUENCE_ACCURACY=70
PATH = "C:\\Users\\Stefan Clinciu\\Documents\\Python\\sha256_family.csv"
csvfile = pandas.read_csv(PATH, encoding='utf-8')
all_hashes_file = os.listdir("C:\\Users\\Stefan Clinciu\\Documents\\Python\\drebin\\drebin\\feature_vectors")
malware_list = csvfile['sha'].tolist()
app = {}
list_of_features = []
i=0
malware_num=0
app_num=0
for file_name in all_hashes_file: 
        if(malware_num < ((malware_num+app_num)/100*31)):
                if(file_name not in malware_list): continue 
        f = open("C:\\Users\\Stefan Clinciu\\Documents\\Python\\drebin\\drebin\\feature_vectors\\"+file_name, 'r')
        f1 = f.readlines()
        features = {}
        for lines in f1:

            #for each line in the file right strip the /n and split the line at '::'  
            #then assign to feature the first part of line and to value the second part
            try:
                lines = lines.rstrip()
                feature = lines[:lines.index("::")]
                value = lines[lines.index("::")+2:]
            except:
                pass
            
            #append a feature in list_of_features to track all different features
            if feature not in list_of_features: list_of_features.append(feature)

            #keep at max MAX_NUM_VALUES values for each faeture
            if feature in features and len(features[feature])>MAX_NUM_VALUES: continue
            counter = 0
            #if feature is already a key in features dictionary append the value else create new key with name feature and val=value    
            if feature in features:

                    #if a value is a URL troncate the url to the first 25 letters,
                    #if they are too similar don't insert it in dictionary to avoid having too many similar urls
                    if(feature == 'url'):
                        flag=False
                        for v in features[feature]:
                                new_v = v[:20]
                                new_value = value[:20]
                                if(difflib.SequenceMatcher(None, new_value, new_v).ratio()<SEQUENCE_ACCURACY): 
                                        flag = True
                        if(flag) : features[feature].append(value)                
                                
                    else:
                        features[feature].append(value)

            else:
                    features[feature]=[value] 
        
        #add class to dict
        if file_name in malware_list:
                malware_num = malware_num+1
                features['classe'] = 1
        else:
                app_num = app_num + 1
                features['classe'] = 0  
        app[file_name]=features
        #increment i and check the num of iterations
        i = i+1

        if(i==NUM_ITERATIONS): break




#create a pandas dataframe from dict
new_dataframe = pandas.DataFrame.from_dict(app, orient='index')

#print('The length of the service_receiver col before deleting NaN values is: '+str(len(new_dataframe.service_receiver)))
#print('The malware num before deleting NaN rows in "service_receiver" is: ' + str(malware_num)) 
#print('The non malware num before deleting NaN rows in "service_receiver" is: ' + str(app_num))

new_dataframe=new_dataframe[pandas.notnull(new_dataframe['service_receiver'])]
new_malware_count=0
new_non_malware_count=0
#for elem in new_dataframe['classe']:
#        if elem == 1: new_malware_count = new_malware_count + 1
#        else: new_non_malware_count = new_non_malware_count + 1
#print('The new length after deleting NaN rows in "service_receiver" is: '+str(len(new_dataframe.service_receiver)))
#print('Malware after deleting NaN rows in "service_receiver" : ' + str(new_malware_count))
#print('Non malware after deleting NaN rows in "service_receiver" : '+str(new_non_malware_count))
#add the class in the list_of_features
list_of_features.append('classe')
print(list_of_features)

#drop provider and service_receiver cols from dataset and from the list_of_features
new_dataframe = new_dataframe.drop('provider', 1)
new_dataframe = new_dataframe.drop('permission', 1)
new_dataframe = new_dataframe.drop('activity', 1)
new_dataframe = new_dataframe.drop('call', 1)
#new_dataframe = new_dataframe.drop('service_receiver', 1)

list_of_features.remove('provider')
list_of_features.remove('permission')
list_of_features.remove('activity')
list_of_features.remove('call')
#list_of_features.remove('service_receiver')
#One Hot Encode all the columns in the dataset
for i in range(len(list_of_features)-1):
        pf = new_dataframe[list_of_features[i]].str.join('|').str.get_dummies()
        
        new_dataframe = new_dataframe.drop(list_of_features[i], 1)
        new_dataframe = pandas.concat([new_dataframe , pf], axis=1)


y = new_dataframe['classe']
X = new_dataframe.drop('classe', 1)


X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.20) 

svclassifier = SVC(kernel='linear')  
svclassifier.fit(X_train, y_train)  
y_pred = svclassifier.predict(X_test) 
 
print(confusion_matrix(y_test,y_pred))  
print(classification_report(y_test,y_pred))  

